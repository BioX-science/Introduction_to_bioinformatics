---
title: "Session #2 - Exercises"
author: "Adrian C Lo"
date: "12/4/2019"
output: html_document
---

## INSTRUCTIONS

There are 3 segments with 10 questions each that increase in difficulty. Fill in the answer within the code chunk. When you wish to test the code chunk, press the *green play button* on the right side of the code chunk to see your output. The hints will guide you what functions are required. You can access further information with *?x* where x is the function name, e.g. ?print().

## BASIC OPERATIONS

1.	Create a vector x containing the elements 0,1,2,3,4,5,6. *HINT: c()*

```{r}

```

2. Write an if-else statement to check the first element of x. If it is zero, output “This is good”, else output “This is bad”. *HINT: print() and logical operator ==*

```{r}

```

3. Write a for-loop that iterates over each element of vector x using print()

```{r}

```

4. Write a for-loop that iterates over each element of vector x and print the cube of each value. *HINT: 2^3 = cube of 2 = 8*

```{r}

```

5.	Write a for-loop that makes a right angle triangle pattern where each row is a number x repeating itself x times. *HINT: rep()*

The pattern is:

1

22

333

4444

```{r}

```

6. Write a for-loop that iterates over the inbuilt iris dataset that evaluates the number of characters in the column name. The output should be like: 

Sepal.Length (12)

Sepal.Width (11)

Petal.Length (12)

Petal.Width (11)

Species (7)

*HINT: paste0() and nchar()*

```{r}

```

7. Write a for-loop that iterates over the inbuilt iris dataset ad outputs for each flower/row as output: Flower *1* is a setosa and has a Sepal.Length of *5.1*

```{r}

```

8. Write a for-loop that iterates over each element of vector y and only outputs the positive numbers, i.e. ignoring the negative numbers. *HINT: next()*

```{r}

```

9. Write a for-loop that iterates over each element of vector y, till it reaches value 10. If it reaches value 10, stop the for-loop. *HINT: break()*

```{r}

```

10. Use the inbuilt rivers dataset and write a for-loop that checks each value. If the value is lower than 500, output “short river”. If the river is more than 2000, output “long river”. Everything else, output the original value.

```{r}

```

## READR and DPLYR

11. Import readr and dplyr packages

```{r}

```

12. Import dataset tidy.csv and store it in an object called "mydata" *HINT: read_csv()*

```{r}

```

13. Check out mydata, how many rows and columns are there?

```{r}

```

14.	Genotype, treatment and gender should be categorical variables with some order (instead of the default alphabetical order). Transform these into order “WT”,”GM” for genotype, “CTR_X”,”TRT_X”,”TRT_Y”,”TRT_Z” for treatment and “M”,”F” for gender. Store it again in object "mydata". *HINT: mutate() and factor(..., levels = c(...)).*

Example: factor(class, levels = c(“level_1”,”level_2”,”level_3”))

```{r}

```

15.	Continue from mydata from question 14. Variables are unnormalized. Create three new columns with the variables multiplied by the norm column. Name the new columns var_x_norm, var_y_norm and var_z_norm. Store in an object called “mydata_t”. *HINT: mutate()*

```{r}

```

16.	Continue from mydata_t. Filter values that only contain male (gender == “M”) samples, store this in an object called “mymales”. Continue working with mymales untill question 20. *HINT: filter()*

```{r}

```

17.	Continue from mymales. The summarise() function is very useful for collapsing a large dataset into a single observation. Summarise the mymales dataset to find the following columns / values: min_value_x_norm (minimum value for var_x_norm) and mean_value_x_norm (mean value for value_x_norm). *HINT: min() and mean() *

```{r}

```

18.	In combination with group_by() function, you can summarise the value of interest by each group. For example, grouping according to genotype, you can find the values of question 17 for each genotype. *HINT: %>% makes the line of execution more readable.* 

Example:

data %>% group_by(x) %>% summarise(...)

is equivalent to (but more readable than)

summarise(group_by(data, x), ...)

```{r}

```

19.	Grouping can be performed on multiple levels. Try to find values of question 17 when grouping for genotype and then treatment. Summaries can also be stored in an object. Store this in object called “mysummary”

```{r}

```

20.	Export your result with write_csv(). Call it “myfirstRoutput.csv”

```{r}

```

## GGPLOT2

21.	Work with mydata_t from the previous segment. Create a boxplot with on the y-axis var_x_norm and on the x-axis genotype. How does your plot look like? What can you conclude from this? *HINT: ggplot(data, aes(x = x, y = y) + geom_boxplot()*

```{r}

```

22.	The previous graph takes a general view of var_x_norm according to genotype. Add within aesthetics (aes) that treatment is defined by fill. *HINT: fill = ...*

```{r}

```

23.	Re-use the code from question 22 and adjust it slightly so you have violinplots instead of boxplots.

```{r}

```

24.	Re-use the code from question 22 and adjust it slightly so you have stacked bars instead of boxplots. *HINT: geom_col()*

```{r}

```

25.	Re-use the code from question 24 and adjust it slightly to have side-by-side bars instead of stacked bars. *HINT: position = “dodge” inside geom_col()*

```{r}

```

26.	Re-use the code from question 24 and adjust it slightly to have stacked bars of equal height, instead of stacked bars with different height. *HINT: position = “fill”*

```{r}

```

27.	Create a scatter plot with on the y-axis var_x_norm and on the x-axis genotype. How does your plot look like? *HINT: geom_point()*

```{r}

```

28.	All points are only segmented according to genotype, but no difference is made between treatments. Add within aesthetics (aes) that treatment is defined by color. *HINT: color ...*

```{r}

```

29.	Treatments are defined with different colors but are all on top of each other. To make more clear. Add inside geom_point() that position has to be changed. This can be done with the statement position = position_dodge(1). The number (0-1) determines how much space there is between the respective columns within genotype. Try out different values to see how it makes the graph more aesthetic/readable.

```{r}

```

30.	Besides colors and fills, shapes can also be used as an aesthetic to define categorical groups. Add shape = gender within aesthetics to see what happens. What can you see? How can the visibility be improved? See facet_wrap() or facet_grid() and try out.

```{r}

```
